setwd("~/Github/BATD Test Bed/New Format")
newFormat_from_all_sites <- list.files(pattern = "*.txt") #list the txt files containing participant's performance
Calgary <- BATD_extract_NF(newFormat_from_all_sites[1], "University of Calgary")
CCH <- BATD_extract_NF(newFormat_from_all_sites[2], "CCH")
KKI <- BATD_extract_NF(newFormat_from_all_sites[3], "KKI")
library(BATD)
setwd("~/Github/BATD Test Bed/New Format")
newFormat_from_all_sites <- list.files(pattern = "*.txt") #list the txt files containing participant's performance
Calgary <- BATD_extract_NF(newFormat_from_all_sites[1], "University of Calgary")
CCH <- BATD_extract_NF(newFormat_from_all_sites[2], "CCH")
KKI <- BATD_extract_NF(newFormat_from_all_sites[3], "KKI")
library(BATD)
setwd("~/Github/BATD Test Bed/New Format")
newFormat_from_all_sites <- list.files(pattern = "*.txt") #list the txt files containing participant's performance
Calgary <- BATD_extract_NF(newFormat_from_all_sites[1], "University of Calgary")
CCH <- BATD_extract_NF(newFormat_from_all_sites[2], "CCH")
KKI <- BATD_extract_NF(newFormat_from_all_sites[3], "KKI")
library(BATD)
setwd("~/Github/BATD Test Bed/New Format")
newFormat_from_all_sites <- list.files(pattern = "*.txt") #list the txt files containing participant's performance
Calgary <- BATD_extract_NF(newFormat_from_all_sites[1], "University of Calgary")
CCH <- BATD_extract_NF(newFormat_from_all_sites[2], "CCH")
KKI <- BATD_extract_NF(newFormat_from_all_sites[3], "KKI")
library(BATD)
setwd("~/Github/BATD Test Bed/New Format")
newFormat_from_all_sites <- list.files(pattern = "*.txt") #list the txt files containing participant's performance
Calgary <- BATD_extract_NF(newFormat_from_all_sites[1], "University of Calgary")
CCH <- BATD_extract_NF(newFormat_from_all_sites[2], "CCH")
KKI <- BATD_extract_NF(newFormat_from_all_sites[3], "KKI")
colnames(first) <- "sessions"
library(BATD)
setwd("~/Github/BATD Test Bed/New Format")
newFormat_from_all_sites <- list.files(pattern = "*.txt") #list the txt files containing participant's performance
Calgary <- BATD_extract_NF(newFormat_from_all_sites[1], "University of Calgary")
CCH <- BATD_extract_NF(newFormat_from_all_sites[2], "CCH")
KKI <- BATD_extract_NF(newFormat_from_all_sites[3], "KKI")
library(BATD)
KKI <- BATD_extract_NF(newFormat_from_all_sites[3], "KKI")
library(BATD)
KKI <- BATD_extract_NF(newFormat_from_all_sites[3], "KKI")
library(BATD)
KKI <- BATD_extract_NF(newFormat_from_all_sites[3], "KKI")
library(BATD)
KKI <- BATD_extract_NF(newFormat_from_all_sites[3], "KKI")
library(BATD)
KKI <- BATD_extract_NF(newFormat_from_all_sites[3], "KKI")
library(BATD)
KKI <- BATD_extract_NF(newFormat_from_all_sites[3], "KKI")
library(BATD)
KKI <- BATD_extract_NF(newFormat_from_all_sites[3], "KKI")
Calgary <- BATD_extract_NF(newFormat_from_all_sites[1], "University of Calgary")
Calgary <- BATD_extract_NF(newFormat_from_all_sites[1], "University of Calgary")
library(BATD)
CCH <- BATD_extract_NF(newFormat_from_all_sites[2], "CCH")
library(BATD)
KKI <- BATD_extract_NF(newFormat_from_all_sites[3], "KKI")
KKI <- BATD_extract_NF(newFormat_from_all_sites[3], "KKI")
library(BATD)
protocols_completed_more_than_once
library(BATD)
KKI <- BATD_extract_NF(newFormat_from_all_sites[3], "KKI")
library(BATD)
KKI <- BATD_extract_NF(newFormat_from_all_sites[3], "KKI")
setwd("~/Github/BATD Test Bed/New Format")
library(BATD)
KKI <- BATD_extract_NF(newFormat_from_all_sites[3], "KKI")
newFormat_from_all_sites <- list.files(pattern = "*.txt") #list the txt files containing participant's performance
KKI <- BATD_extract_NF(newFormat_from_all_sites[3], "KKI")
library(BATD)
KKI <- BATD_extract_NF(newFormat_from_all_sites[3], "KKI")
KKI <- BATD_extract_NF(newFormat_from_all_sites[3], "KKI")
library(BATD)
library(BATD)
library(BATD)
KKI <- BATD_extract_NF(newFormat_from_all_sites[3], "KKI")
KKI <- BATD_extract_NF(newFormat_from_all_sites[3], "KKI")
library(BATD)
library(BATD)
KKI <- BATD_extract_NF(newFormat_from_all_sites[3], "KKI")
Calgary <- BATD_extract_NF(newFormat_from_all_sites[1], "University of Calgary")
CCH <- BATD_extract_NF(newFormat_from_all_sites[2], "CCH")
KKI <- BATD_extract_NF(newFormat_from_all_sites[3], "KKI")
Toronto <- BATD_extract_NF(newFormat_from_all_sites[4], "Toronto_ARBA1")
newFormat_from_all_sites_df <- rbind(Calgary, CCH, KKI, Toronto)
analyzedAll <- BATD_analyze_all(newFormat_from_all_sites_df)
BATD_plot_all(Calgary)
SMD <- KKI[KKI$protocolName=="Simultaneous Amplitude Discrimination",]
KKI <- BATD_extract_NF(newFormat_from_all_sites[3], "KKI")
setwd("~/Github/BATD Test Bed/New Format")
newFormat_from_all_sites <- list.files(pattern = "*.txt") #list the txt files containing participant's performance
Calgary <- BATD_extract_NF(newFormat_from_all_sites[1], "University of Calgary")
CCH <- BATD_extract_NF(newFormat_from_all_sites[2], "CCH")
KKI <- BATD_extract_NF(newFormat_from_all_sites[3], "KKI")
Toronto <- BATD_extract_NF(newFormat_from_all_sites[4], "Toronto_ARBA1")
newFormat_from_all_sites_df <- rbind(Calgary, CCH, KKI, Toronto)
analyzedAll <- BATD_analyze_all(newFormat_from_all_sites_df)
BATD_extract_NF(newFormat_from_all_sites[4], "Toronto_ARBA1")
Toronto <- BATD_extract_NF(newFormat_from_all_sites[4], "TorontoARBA1")
newFormat_from_all_sites <- list.files(pattern = "*.txt") #list the txt files containing participant's performance
Calgary <- BATD_extract_NF(newFormat_from_all_sites[1], "University of Calgary")
CCH <- BATD_extract_NF(newFormat_from_all_sites[2], "CCH")
KKI <- BATD_extract_NF(newFormat_from_all_sites[3], "KKI")
Toronto <- BATD_extract_NF(newFormat_from_all_sites[4], "TorontoARBA1")
library(BATD)
newFormat_from_all_sites <- list.files(pattern = "*.txt") #list the txt files containing participant's performance
Calgary <- BATD_extract_NF(newFormat_from_all_sites[1], "University of Calgary")
CCH <- BATD_extract_NF(newFormat_from_all_sites[2], "CCH")
KKI <- BATD_extract_NF(newFormat_from_all_sites[3], "KKI")
Toronto <- BATD_extract_NF(newFormat_from_all_sites[4], "TorontoARBA1")
library(BATD)
newFormat_from_all_sites <- list.files(pattern = "*.txt") #list the txt files containing participant's performance
Calgary <- BATD_extract_NF(newFormat_from_all_sites[1], "University of Calgary")
CCH <- BATD_extract_NF(newFormat_from_all_sites[2], "CCH")
KKI <- BATD_extract_NF(newFormat_from_all_sites[3], "KKI")
Toronto <- BATD_extract_NF(newFormat_from_all_sites[4], "TorontoARBA1")
first
library(BATD)
KKI <- BATD_extract_NF(newFormat_from_all_sites[3], "KKI")
library(BATD)
KKI <- BATD_extract_NF(newFormat_from_all_sites[3], "KKI")
KKI <- BATD_extract_NF(newFormat_from_all_sites[3], "KKI")
library(BATD)
KKI <- BATD_extract_NF(newFormat_from_all_sites[3], "KKI")
library(BATD)
KKI <- BATD_extract_NF(newFormat_from_all_sites[3], "KKI")
library(BATD)
KKI <- BATD_extract_NF(newFormat_from_all_sites[3], "KKI")
library(BATD)
KKI <- BATD_extract_NF(newFormat_from_all_sites[3], "KKI")
library(BATD)
KKI <- BATD_extract_NF(newFormat_from_all_sites[3], "KKI")
KKI <- BATD_extract_NF(newFormat_from_all_sites[3], "KKI")
KKI <- BATD_extract_NF(newFormat_from_all_sites[3], "KKI")
library(BATD)
KKI <- BATD_extract_NF(newFormat_from_all_sites[3], "KKI")
KKI
library(BATD)
setwd("~/Github/BATD Test Bed/New Format")
newFormat_from_all_sites <- list.files(pattern = "*.txt") #list the txt files containing participant's performance
Calgary <- BATD_extract_NF(newFormat_from_all_sites[1], "University of Calgary")
CCH <- BATD_extract_NF(newFormat_from_all_sites[2], "CCH")
KKI <- BATD_extract_NF(newFormat_from_all_sites[3], "KKI")
Toronto <- BATD_extract_NF(newFormat_from_all_sites[4], "TorontoARBA1")
newFormat_from_all_sites_df <- rbind(Calgary, CCH, KKI, Toronto)
analyzedAll <- BATD_analyze_all(newFormat_from_all_sites_df)
BATD_plot_all(newFormat_from_all_sites_df)
library(BATD)
KKI <- BATD_extract_NF(newFormat_from_all_sites[3], "KKI")
library(BATD)
KKI <- BATD_extract_NF(newFormat_from_all_sites[3], "KKI")
KKI <- BATD_extract_NF(newFormat_from_all_sites[3], "KKI")
library(BATD)
KKI <- BATD_extract_NF(newFormat_from_all_sites[3], "KKI")
library(BATD)
KKI <- BATD_extract_NF(newFormat_from_all_sites[3], "KKI")
library(BATD)
KKI
KKI <- BATD_extract_NF(newFormat_from_all_sites[3], "KKI")
library(BATD)
library(BATD)
KKI <- BATD_extract_NF(newFormat_from_all_sites[3], "KKI")
library(BATD)
KKI <- BATD_extract_NF(newFormat_from_all_sites[3], "KKI")
library(BATD)
KKI <- BATD_extract_NF(newFormat_from_all_sites[3], "KKI")
library(BATD)
KKI <- BATD_extract_NF(newFormat_from_all_sites[3], "KKI")
library(BATD)
KKI <- BATD_extract_NF(newFormat_from_all_sites[3], "KKI")
library(BATD)
KKI <- BATD_extract_NF(newFormat_from_all_sites[3], "KKI")
KKI <- BATD_extract_NF(newFormat_from_all_sites[3], "KKI")
library(BATD)
library(BATD)
KKI <- BATD_extract_NF(newFormat_from_all_sites[3], "KKI")
KKI <- BATD_extract_NF(newFormat_from_all_sites[3], "KKI")
library(BATD)
CCH <- BATD_extract_NF(newFormat_from_all_sites[2], "CCH")
CCH <- BATD_extract_NF(newFormat_from_all_sites[2], "CCH")
library(BATD)
KKI <- BATD_extract_NF(newFormat_from_all_sites[3], "KKI")
library(BATD)
KKI <- BATD_extract_NF(newFormat_from_all_sites[3], "KKI")
KKI[KKI$protocolName=="Simultaneous Amplitude Discrimination",]
KKI[KKI$protocolName=="Simultaneous Amplitude Discrimination",][1:24]
KKI[KKI$protocolName=="Simultaneous Amplitude Discrimination"][1:24]
KKI[KKI$protocolName=="Simultaneous Amplitude Discrimination",][,1:24]
KKI[KKI$protocolName=="Simultaneous Amplitude Discrimination",][1:24,]
KKI[KKI$protocolName=="Simultaneous Amplitude Discrimination",][1:25,]
KKI[KKI$protocolName=="Simultaneous Amplitude Discrimination",][25:50,]
KKI[KKI$protocolName=="Simultaneous Amplitude Discrimination",][25:51,]
KKI[KKI$protocolName=="Simultaneous Amplitude Discrimination",][25:52,]
KKI[KKI$protocolName=="Simultaneous Amplitude Discrimination",][25:53,]
KKI$sessions[KKI$protocolName=="Simultaneous Amplitude Discrimination",][25:52,]
KKI$sessions[KKI$protocolName=="Simultaneous Amplitude Discrimination"][25:52,]
KKI$sessions[KKI$protocolName=="Simultaneous Amplitude Discrimination"][25:52]
KKI$sessions[KKI$protocolName=="Simultaneous Amplitude Discrimination"][25:52] <- 2
KKI$sessions
KKI$sessions[KKI$protocolName=="Simultaneous Amplitude Discrimination"][25:52] <- 2
KKI$sessions[KKI$protocolName=="Simultaneous Amplitude Discrimination"][25:52]
library(BATD)
KKI <- BATD_extract_NF(newFormat_from_all_sites[3], "KKI")
library(BATD)
KKI <- BATD_extract_NF(newFormat_from_all_sites[3], "KKI")
setwd("~/Github/BATD Test Bed/New Format")
newFormat_from_all_sites <- list.files(pattern = "*.txt") #list the txt files containing participant's performance
Calgary <- BATD_extract_NF(newFormat_from_all_sites[1], "University of Calgary")
CCH <- BATD_extract_NF(newFormat_from_all_sites[2], "CCH")
KKI <- BATD_extract_NF(newFormat_from_all_sites[3], "KKI")
Toronto <- BATD_extract_NF(newFormat_from_all_sites[4], "TorontoARBA1")
newFormat_from_all_sites_df <- rbind(Calgary, CCH, KKI, Toronto)
analyzedAll <- BATD_analyze_all(newFormat_from_all_sites_df)
BATD_plot_all(newFormat_from_all_sites_df)
CCH
Calgary[Calgary$protocol==905]
Calgary[Calgary$protocol==905,]
Calgary[Calgary$protocol==905,]
participantTactileData$protocolName[participantTactileData$protocol==905 & participantTactileData$ISI==100] <- "Sequential Amplitude Discrimination" #Sequential amplitude discrimination for Calgary
library(BATD)
setwd("~/Github/BATD Test Bed/New Format")
newFormat_from_all_sites <- list.files(pattern = "*.txt") #list the txt files containing participant's performance
Calgary <- BATD_extract_NF(newFormat_from_all_sites[1], "University of Calgary")
CCH <- BATD_extract_NF(newFormat_from_all_sites[2], "CCH")
KKI <- BATD_extract_NF(newFormat_from_all_sites[3], "KKI")
Toronto <- BATD_extract_NF(newFormat_from_all_sites[4], "TorontoARBA1")
newFormat_from_all_sites_df <- rbind(Calgary, CCH, KKI, Toronto)
analyzedAll <- BATD_analyze_all(newFormat_from_all_sites_df)
BATD_plot_all(newFormat_from_all_sites_df)
#' BATD_extract_NF
#'
#' Takes a list of filenames in a working directory which contain the performance data recorded from Cortical Metrics. These performance files are typically .txt files. "BATD_extract_NF" was specifically designed to analyze data from Brain Gauge devices.
#' For more information about Cortical Metrics Brain Gauage, see: https://www.corticalmetrics.com/braingauge. BATD_extract_NF requires two inputs, with the first being the list of participants and the second being a string variable referring to the site where the data was collected.
#' While both "BATD_extract_NF" and "BATD_extract_OF" return a combined dataframe for all the participants that have had their data extracted, the individual and combined files are saved in folders created in the original working directory.
#' In the working directory, folders 'output' and 'combined' will be created to store the individual files that were extracted and a file containing all the individual files combined respectively. These files are in .csv format.
#'
#' @param list_of_filenames a list object containing the filenames of the .txt files containing participant performance from Brain Gauge
#' @param Site refers to the site where the data was collected. In the past and in the future, the original codes will be patched for different sites. For Site, put the site location inbetween two quotation marks. For e.g., "JHU" refers to the Johns Hopkins University
#'
#' @return BATD_extract_NF returns a dataframe containing the extracted data for each participant. Protocols and protocol names are provided as columns, along with other relevant metrics.
#'
#' @examples
#' currently NA
#'
#' @export
BATD_extract_NF <- function(list_of_filenames, Site){
##VERSION
Version <- c("BATD_V.1.5")
#DEBUGGING ----
debugging <- "off"
if(debugging=="on"){
setwd("~/Dropbox/Documents/Data repository/Tactile Data/Raw/New Format/CCH") #setwd to old format data from JHU
participants_from_CCH <- list.files(pattern = "-") #identify all the participants in the folder
}
'%ni%' <- Negate('%in%') #create the function for %not in%
## SECTION 1 ----
# SECTION 1.0 (Setup and entry into the master for loop)
inputDirectory <- getwd() #get the current wd
dir.create("output", showWarnings = FALSE) #create a folder called "output" for the output
outputDirectory <- paste0(inputDirectory,"/output") #create a variable which denotes the output directory
allParticipantsOutput <- list()
for(p in 1:length(list_of_filenames)){#For loop through the participants identified in the inputDirectory
setwd(inputDirectory) #set working directory
output <- read.csv(list_of_filenames[p], header = FALSE) #read in the current participant[p]'s file
if(debugging=="on"){print("SECTION 1.0: (Setup and entry into the master for loop) - COMPLETED")}
# SECTION 1.1 (cleaning) ----
#General data cleaning prior to extraction
output$V1 <- as.character(output$V1) #turn column 1 into a character
output$V1 <- gsub(" ","",output$V1) #replace all blank spaces in column 1
tempo <- suppressWarnings(t(as.data.frame(strsplit(output$V1,":")))) #split the string by ':' and transpose it to long format
rownames(tempo) <- c() #clear the row numbers
temp <- suppressWarnings(as.data.frame(tempo)) #turn the output into a dataframe
if(debugging=="on"){print("SECTION 1.1: (cleaning) - COMPLETED")}
# SECTION 1.2 (splitting the dataframe into separate protocols ) ----
#Break the dataframe up into separate protocols stored in a list
#Use "X" to mark the beginning of each protocol
temp$V4 <- ifelse(temp$V1=="date", "X",NA) #All of the files start with date, we will use date as marker of the start of each protocol - create a column which marks date with a 'X'
protocols <- (which(temp$V4=="X")) #This line tells us all of the instances in *which* 'X' occurs
protocols <- as.list(protocols)
list <- list() #Create a list external of the for loop for breaking the output into seperate protocols
for (i in (1:length(protocols))){
if(i==length(protocols)){break} #Note to self, if it's 14, then we want i+1 to be something else (i.e., the end of the file)
list[[i]] <-  temp[(paste(protocols[i])):(paste(protocols[i+1])),]
} #loop for breaking the output into separate protocols
list[[i]] <- temp[(paste(protocols[i])):nrow(temp),] #puts the last protocol into the list (for loop above cannot account for last protocol)
if(debugging=="on"){print("SECTION 1.2: (splitting the dataframe into separate protocols) - COMPLETED")}
# SECTION 1.3 (for loop through the protocols in the folder and extracting the participant/protocol/performance details) ----
ProtocolOutputList <- list()
for (i in (1:length(list))){
output <- list[[i]]
rownames(output) <- c() #clear the row numbers
# (1) Extract Participant details ----
race <- as.character(output$V2[output$V1=="race"])[1]
gender <- as.character(output$V2[output$V1=="gender"])[1]
handedness <- as.character(output$V2[output$V1=="handedness"])[1]
birthYear <- as.character(output$V2[output$V1=="birthYear"])[1]
id <- as.character(output$V2[output$V1=="number"]) [1]#is this participant id?
participantDetails <- as.data.frame(cbind(id, race, gender, handedness, birthYear))
# (2) Extract Protocol Details ----
date <- substr(gsub("T","",(output$V2[output$V1=="date"][1])), 1,10)
timeProtocolStarted <-  paste0(substr(gsub("T","",(output$V2[output$V1=="date"][1])), 11,12),":", substr(gsub("T","",(output$V3[output$V1=="date"][1])), 1,2))
site <- Site
format <- "NF"
extractedBy <- Version
protocol <- as.character(output$V2[output$V1=="protocol"])
numberofPracticeTrials <- as.character(output$V2[output$V1=="numTrainingTrials"][1])
numberofTestTrials <- as.character(output$V2[output$V1=="numTrials"][1])
stim1amplitude <- as.character(output$V2[output$V1=="amplitude"])[1]
stim2amplitude <- as.character(output$V2[output$V1=="amplitude"])[2]
astim1amplitude <- as.character(output$V2[output$V1=="amplitude"])[3]
astim2amplitude <- as.character(output$V2[output$V1=="amplitude"])[4]
stim1duration <- as.character(output$V2[output$V1=="duration"])[1]
stim2duration <- as.character(output$V2[output$V1=="duration"])[2]
astim1duration <- as.character(output$V2[output$V1=="duration"])[3]
astim2duration <- as.character(output$V2[output$V1=="duration"])[4]
#output$V1[output$V1=="ITI"] <- "ISI" #for the new format, ISI is referred to as ITI
ISI <- suppressWarnings(as.numeric(as.character(output$V2[output$V1=="ITI"][1])))
originalFilename <- list_of_filenames[p]
protocolDetails <- as.data.frame(cbind(date, timeProtocolStarted, site, format, extractedBy, protocol, numberofPracticeTrials, numberofTestTrials, ISI,
stim1amplitude, stim2amplitude,
astim1amplitude, astim2amplitude,
stim1duration, stim2duration,
astim1duration, astim2duration, originalFilename))
# (3) Extract Performance details ----
value <- as.character(output$V2[output$V1=="value"])
expected <- as.character(output$V2[output$V1=="expected"])
response <- as.character(output$V2[output$V1=="response"])
correctResponse <- as.character(output$V2[output$V1=="correct"])
responseTime <- as.character(output$V2[output$V1=="responseTime"])
performanceDetails <- as.data.frame(cbind(value, expected, response, correctResponse, responseTime))
All <- cbind(participantDetails, protocolDetails, performanceDetails)
All$trialNumber <- 1:nrow(All)
ProtocolOutputList[[i]] <- All
}
participantTactileData <- do.call(rbind.data.frame, ProtocolOutputList)
#Change correctResponse to a 0 or 1 numeric (currently its in true or false, I just want to standardise this between the old and new format, also string descriptions are not useful here)
participantTactileData$correctResponse  <- as.character(participantTactileData$correctResponse)
participantTactileData$correctResponse[participantTactileData$correctResponse=="true"] <- "1"
participantTactileData$correctResponse[participantTactileData$correctResponse=="false"] <- "0"
if(debugging=="on"){print("(SECTION 1.3: For loop through the protocols in the folder and extracting the participant/protocol/performance details) - COMPLETED")}
# SECTION 1.4 (label the protocols) ----
#Label protocols with names (note that this is done in a specific order since sometimes protocols share numeric codes
#Note, there are far more protocols in the new format than the old format, hence the greater number of protocol numbers
participantTactileData$protocolName[participantTactileData$protocol==801] <- "Simple Reaction Time"
participantTactileData$protocolName[participantTactileData$protocol==800] <- "Choice Reaction Time"
participantTactileData$protocolName[participantTactileData$protocol==100 & participantTactileData$stim1amplitude==0] <- "Static Detection Threshold"
participantTactileData$protocolName[participantTactileData$protocol==900 & participantTactileData$stim1amplitude==0] <- "Static Detection Threshold"
participantTactileData$protocolName[participantTactileData$protocol==910 & participantTactileData$ISI==5000] <- "Static Detection Threshold"
participantTactileData$protocolName[participantTactileData$protocol==910 & participantTactileData$ISI==30] <- "Static Detection Threshold with Adaptation ISI 30"
participantTactileData$protocolName[participantTactileData$protocol==910 & participantTactileData$ISI==100] <- "Static Detection Threshold with Adaptation ISI 100"
participantTactileData$protocolName[participantTactileData$protocol==713] <- "Dynamic Detection Threshold"
participantTactileData$protocolName[participantTactileData$protocol==900 & participantTactileData$stim1amplitude==100] <- "Sequential Amplitude Discrimination"
participantTactileData$protocolName[participantTactileData$protocol==100 &  participantTactileData$stim1amplitude==100] <- "Sequential Amplitude Discrimination"
participantTactileData$protocolName[participantTactileData$protocol==100 & participantTactileData$protocolName != "Static Detection Threshold"]
participantTactileData$protocolName[participantTactileData$protocol==900 & participantTactileData$stim2amplitude!=0] <- "Simultaneous Amplitude Discrimination"
participantTactileData$protocolName[participantTactileData$protocol==105] <- "Simultaneous Amplitude Discrimination"
participantTactileData$protocolName[participantTactileData$protocol==905 & participantTactileData$ISI==100] <- "Sequential Amplitude Discrimination" #Sequential amplitude discrimination for Calgary
participantTactileData$protocolName[participantTactileData$protocol==925] <- "Sequential Frequency Discrimination"
participantTactileData$protocolName[participantTactileData$protocol==920] <- "Simultaneous Frequency Discrimination"
participantTactileData$protocolName[participantTactileData$protocol==171 & participantTactileData$astim2amplitude==100] <- "Amplitude Discrimination with Single Site Adaptation"
participantTactileData$protocolName[participantTactileData$protocol==171 & participantTactileData$astim1amplitude==100] <- "Amplitude Discrimination with Dual Site Adaptation"
participantTactileData$protocolName[participantTactileData$protocol==171 & participantTactileData$astim1amplitude==200] <- "Dual Staircase Amplitude Discrimination (up)"
participantTactileData$protocolName[participantTactileData$protocol==171 & participantTactileData$astim2amplitude==200] <- "Dual Staircase Amplitude Discrimination (down)"
participantTactileData$protocolName[participantTactileData$protocol==350] <- "Duration Discrimination"
participantTactileData$protocolName[participantTactileData$protocol==950] <- "Duration Discrimination"
participantTactileData$protocolName[participantTactileData$protocol==930] <- "Temporal Order Judgement"
participantTactileData$protocolName[participantTactileData$protocol==931] <- "Temporal Order Judgement with Carrier"
if(debugging=="on"){print("(SECTION 1.4: label the protocols - COMPLETED")}
# SECTION 1.5 (#Accounting for session) ----
#Create a column for the sessions a participant completed (based on the date)
participantTactileData$date <- as.Date(participantTactileData$date)
dates <- sort(unique(participantTactileData$date))
timePointList <- list()
for (d in 1:length(dates)){
givenDate <- participantTactileData[participantTactileData$date==dates[d],]
givenDate$session <- d
timePointList[[d]] <- givenDate}
participantTactileData <- plyr::rbind.fill(timePointList)
#Split the dataframe into the sessions
sessions <- unique(participantTactileData$session)
sessionDataList <- list()
for(s in 1:length(sessions)){
participantData_at_s_session <- participantTactileData[participantTactileData$session==sessions[s],] #subset to the current session
participantData_at_s_session$timeProtocolStarted <- as.POSIXct(participantData_at_s_session$timeProtocolStarted,format="%H:%M") #convert the time variable to time (ignore the inclusion of the current YEAR)
participantData_at_s_session <- participantData_at_s_session[with(participantData_at_s_session, order(participantData_at_s_session$timeProtocolStarted)),] #sort in ascending order based on the time the protocol was completed
participantData_at_s_session$orderCompleted <- cumsum(c(0,as.numeric(diff(participantData_at_s_session$timeProtocolStarted))!=0)) + 1 #create a column for the completion order of the protocols (I cannot remember how the cumsum function works)
sessionDataList[[s]] <- participantData_at_s_session
}
participantTactileData <- plyr::rbind.fill(sessionDataList)
if(debugging=="on"){print("(SECTION 1.5: Accounting for sessions - COMPLETED")}
allProtocolOutputs <- participantTactileData
# SECTION 1.6 (Accounting for discrimination tasks not subtracting the comparison stimulus (this issue is specific to the new format at some sites (i.e., University of Calgary))) ----
if(Site == "University of Calgary"){
allProtocolOutputs$value[grep("Amplitude Discrimination", allProtocolOutputs$protocolName)] <- allProtocolOutputs$value[grep("Amplitude Discrimination", allProtocolOutputs$protocolName)]-200
allProtocolOutputs$value[grep("Frequency Discrimination", allProtocolOutputs$protocolName)] <- allProtocolOutputs$value[grep("Frequency Discrimination", allProtocolOutputs$protocolName)]-30
}
if(Site %in% c("KKI","CCH","JHU")){
#Note to self, this is a temporary brute force fix for the problem that we have where the number of trials completed by protocol are NOT equal
#I will eventually need the code to recognize how many trials were completed within a given session, rather than assume it is exactly half of the total number of tirals completed
# allProtocolOutputs$sessions[allProtocolOutputs$protocolName=="Simultaneous Amplitude Discrimination"][25:52] <- 2
#The data collected from KKI, CCH and JHU has a peculiarity where the practice trials were saved as a protocol within themselves (for only SOME protocols), something that is not the case with data collected elsewhere
#The code below fixes the issue by assigning all protocols to have 3 practice trials, and 20 test trials (which is *currently* true)
allProtocolOutputs$numberofPracticeTrials[is.na(allProtocolOutputs$numberofPracticeTrials)] <- allProtocolOutputs$numberofTestTrials[is.na(allProtocolOutputs$numberofPracticeTrials)]
allProtocolOutputs$numberofTestTrials <- 20
}
if(debugging=="on"){print("(SECTION 1.6: (Accounting for discrimination tasks not subtracting the comparison stimulus - COMPLETED")}
# SECTION 1.7 (Tidying up the dataframe) ----
#Change performance column values to numeric
allProtocolOutputs <- suppressWarnings(as.data.frame(allProtocolOutputs))
allProtocolOutputs[,20:25] <- suppressWarnings(sapply(allProtocolOutputs[,20:25], suppressWarnings(as.character))) #supressWarnings is on because some values are already NA and then turn into NA
allProtocolOutputs[,20:25] <- suppressWarnings(sapply(allProtocolOutputs[,20:25], suppressWarnings(as.numeric)))
if(debugging=="on"){print("(SECTION 1.7: Tidying up the dataframe - COMPLETED")}
# SECTION 1.8 (Saving individual extracted csv files) ----
currentDirectory <- getwd() #remember the current wd
setwd(outputDirectory) #setwd to the outputDirectory
write.csv(allProtocolOutputs, file = paste0("BATD_extracted_", list_of_filenames[p],"_NF.csv")) #save the output of all the protocols for each participant as a csv
setwd(currentDirectory) #return to the currentDirectory
allParticipantsOutput[[p]] <- as.data.frame(allProtocolOutputs)
if(debugging=="on"){print("(SECTION 1.8: Saving individual extracted csv files - COMPLETED")}
print(paste("Extracted participant:", id))
} #exit for loop from SECTION 1
if(debugging=="on"){print("Succesfully Completed SECTION 1: For loop exited")}
allParticipantsOutput_combined <-  as.data.frame(data.table::rbindlist(allParticipantsOutput, fill = TRUE)) #combine the output into a unitary dataframe
## SECTION 2 (Accounting for multiple runs ) -----
#I genuinely apologize for the stress that anyone who has to read through SECTION 2 of the code will inevitably go through, it is very convoluted and likely inefficient
#This section accounts for the fact that *some* protocols have participants complete the same protocol twice
#Here we account for this by splitting the data into a) the participants, b) the sessions that participant completed and c) the protocols completed by that participant within that session
#Once we are at the level of the protocols that participant completed, we then reorder the protocols completed using the TIME at which the protocol started
#We then give each protocol a number for the order in which it was completed
#Unfortunately, this has been done through a series of nested for loops, which makes it difficult to navigate and troubleshoot
# SECTION 2.1 (setup) ----
alldata <- allParticipantsOutput_combined #assign the output from SECTION 1 to a new dataframe called 'alldata'
alldata <- alldata[!is.na(alldata$protocolName),] #remove any rows where the protocol name is not avaialble (if the above has run correctly, this should not even be necessary)
uniqueParticipants <- unique(alldata$id) #identify the unique ids of all the participants that have been extracted
uniqueParticipants <- uniqueParticipants[!is.na(uniqueParticipants)] #remove any participants whose id is NA
#Create a series of external lists for the for loops below
participants_outPut_list <- list()
participants_detail_list <- list()
participant_data_after_accounting_for_runs <- list()
# SECTION 2.2 (split dataframe by unique participants) ----
for(x in 1:length(uniqueParticipants)){
participantData <- alldata[alldata$id==uniqueParticipants[x],] #subset to the current participant (denoted by uniqueParticipants[x])
#print(paste("ID at the start of the loop:",participantData$id[x]))
sessions <- unique(participantData$session) #identify the number of unique sessions completed by this participant (provided by Section 6, based on date)
sessions_for_loop_output <- list()
# SECTION 2.3 (split dataframe further into unique sessions completed by a given participant) ----
for(s in 1:length(sessions)){
participantSessionData <- participantData[participantData$session==sessions[s],] #subset to the current session
protocols_within_session_completed <- as.character(unique(participantSessionData$protocolName)) #identify the protocols that were completed within the given session
list_of_protocols_completed_with_runs <- list()
#SECTION 2.4 (split dataframe further into unique protocols completed by a given participant for a given session) ----
for(p in 1:length(protocols_within_session_completed)){
protocolName <- protocols_within_session_completed[p]
numberofRuns <- nlevels(as.factor(participantSessionData$orderCompleted[participantSessionData$protocolName==protocols_within_session_completed[p]]))
ProtocolRuns <- as.data.frame(cbind(protocolName, numberofRuns))
list_of_protocols_completed_with_runs[[p]] <- ProtocolRuns
}
protocols_completed_by_runs <- plyr::rbind.fill(list_of_protocols_completed_with_runs) #table with protocolNames and the number of runs for each protocolName
protocols_completed_by_runs$numberofRuns <- as.numeric(as.character(protocols_completed_by_runs$numberofRuns))
names_of_protocols_completed_more_than_once <- protocols_completed_by_runs$protocolName[as.numeric(as.character(protocols_completed_by_runs$numberofRuns)) > 1]
names_of_protocols_completed_only_once <- protocols_completed_by_runs$protocolName[protocols_completed_by_runs$numberofRuns == 1]
#SECTION 2.4.1 Create a column called run (and give number referring to the run number) ----
#Protocols completed more than once ----
if(length(names_of_protocols_completed_more_than_once) > 0){
#1. Identify which protocols were completed more than once, and how many times they were completed more than once
#2. subset to the protocol completed more than once and add this to a column called run
list_of_protocols_completed_more_than_once <- list()
for(o in 1:length(names_of_protocols_completed_more_than_once)){
protocol_completed_more_than_once <- participantSessionData[participantSessionData$protocolName==names_of_protocols_completed_more_than_once[o],] #subset to the protocol completed more than once
number_of_runs <- length(unique(protocol_completed_more_than_once$orderCompleted)) #identifies the number of runs
run_number <- unique(protocol_completed_more_than_once$orderCompleted) #identifies the run number
list_of_runs <- list()
for(r in 1:number_of_runs){
currentRun <- protocol_completed_more_than_once[protocol_completed_more_than_once$orderCompleted==run_number[r],] #subset to the 'r' unique run, given by the orderCompleted
currentRun$run <- r #apply run number to column
list_of_runs[[r]] <- currentRun
}
protocol_completed_more_than_once <- plyr::rbind.fill(list_of_runs)
list_of_protocols_completed_more_than_once[[p]] <- protocol_completed_more_than_once
}
all_protocols_completed_more_than_once <- plyr::rbind.fill(list_of_protocols_completed_more_than_once)
}#end of if length(names_of_protocols_completed_more_than_once > 0)
#protocols completed only once ----
if(length(names_of_protocols_completed_only_once) > 0){
all_protocols_completed_just_once <- participantSessionData[!participantSessionData$protocolName %in% names_of_protocols_completed_more_than_once,] #subset to the protocols only completed once
all_protocols_completed_just_once$run <- 1 #add run number
} #end of if length(names_of_protocols_completed_only_once > 0)
#Recombine the protocols completed more than once back with the protocols completed only once ----
if(length(names_of_protocols_completed_more_than_once) > 0){
combined_protocol_data <- rbind(all_protocols_completed_more_than_once, all_protocols_completed_just_once)
}
else {combined_protocol_data <- all_protocols_completed_just_once #if there were only protocols ocompleted once, than combined_protocol-data are just the protocols completed once
}
sessions_for_loop_output[[s]] <- combined_protocol_data
} #end of sessions loop
combined_protocol_data_with_runs <- plyr::rbind.fill(sessions_for_loop_output)
combined_protocol_data_with_runs <- combined_protocol_data_with_runs[with(combined_protocol_data_with_runs, order(combined_protocol_data_with_runs$orderCompleted)),] #sort though that the orderCompleted is in order again (was out of order based on rbind above)
participant_data_after_accounting_for_runs[[x]] <- combined_protocol_data_with_runs
# print(paste("ID at the end of the loop:",participantData$id[x]))
} #end of participant loop
combined_participant_data_after_accounting_for_runs <- plyr::rbind.fill(participant_data_after_accounting_for_runs)
if(debugging=="on"){print("Succesfully Completed SECTION 2: Runs accounted for")}
#SECTION 3 (Saving the combined data) ----
# setwd(inputDirectory)
# dir.create("combined", showWarnings = FALSE) #set the wd to the folder where you wish to save the combined data to
# combinedDirectory <- paste0(inputDirectory,"/combined") #automatically creates a folder in that directory named 'output' - if you already have a folder named output, ignore this code.
# setwd(combinedDirectory)
# write.csv(combined_participant_data_after_accounting_for_runs, file = "BATD_extracted_combined.csv")
# setwd(inputDirectory)
# print(paste0("Combined extracted data saved in:", combinedDirectory))
# if(debugging=="on"){print("(Succesfully completed SECTION 3: Combined data saved")}
return(combined_participant_data_after_accounting_for_runs)
}
